// source: UserManagementService.proto
// Version: 1.0.0

package server

import (
	"context"
	"fmt"
	"job-seek/pkg/database/model"
	"job-seek/pkg/protos"
	"net/http"
	"regexp"
	"strconv"
	"strings"

	"github.com/k0kubun/pp/v3"
	"github.com/sirupsen/logrus"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// CreateUserProfile implements CreateUserProfile from UserManagementServiceServer
// generated by protoc-gen-go-grpc.UserManagementServiceServer
func (s UserManagementServiceServerImpl) CreateUserProfile(ctx context.Context, req *protos.UserProfile) (*protos.UserResponse, error) {
	s.log.WithFields(logrus.Fields{
		"request": req,
	}).Info("CreateUserProfile")

	if err := checkUserProfileEmptyFields(req); err != nil {
		s.log.WithFields(logrus.Fields{
			"error": err,
		}).Error("Failed to create user profile, empty fields")
		return nil, err
	}

	acc, err := s.fetchUserAccount(req.UserId, "", "")
	if err != nil {
		s.log.WithFields(logrus.Fields{
			"error": err,
		}).Error("Failed to fetch user account")
		return nil, status.Errorf(codes.NotFound, "Failed to fetch user account: %v", err)
	}
	if acc == nil {
		s.log.WithFields(logrus.Fields{
			"error": err,
		}).Error("Failed to fetch user account, user not found")
		return nil, status.Errorf(codes.NotFound, "Failed to fetch user account: %v", err)
	}

	// Save the user profile to the database
	user, err := s.storeUserProfileToDB(req)
	if err != nil {
		s.log.WithFields(logrus.Fields{
			"error": err,
		}).Error("Failed to create user profile")
		return nil, status.Errorf(codes.Internal, "Failed to create user profile: %v", err)
	}

	go func() {
		s.log.WithFields(logrus.Fields{
			"user": user,
		}).Info("User profile created successfully")
		s.log.Info("Start to postprocess user profile")

	}()

	return &protos.UserResponse{
		UserId:  fmt.Sprintf("%d", user.ID),
		Status:  "success",
		Message: "User profile created successfully",
	}, nil

	// return nil, status.Errorf(codes.Unimplemented, "method  CreateUserProfile  not implemented")
}

func checkUserProfileEmptyFields(req *protos.UserProfile) error {
	// You can use a database query or any other method to check the email
	// Return true if the email is registered, false otherwise
	if req.Title == "" {
		return status.Errorf(codes.InvalidArgument, "Title cannot be empty")
	}
	if req.UserId == "" {
		return status.Errorf(codes.InvalidArgument, "Reference UserId cannot be empty")
	}
	if req.Position == "" {
		return status.Errorf(codes.InvalidArgument, "Position cannot be empty")
	}
	if req.Description == "" {
		return status.Errorf(codes.InvalidArgument, "Description cannot be empty")
	}

	return nil
}

func (s UserManagementServiceServerImpl) storeUserProfileToDB(user *protos.UserProfile) (*model.UserProfileModel, error) {
	// You can use a database query or any other method to save the user
	// Return an error if the save operation fails, nil otherwise
	instanceModel := &model.UserProfileModel{}
	instanceModel.FromProto(user)
	if err := instanceModel.CreateModel(s.dbClient); err != nil {
		return nil, err
	}
	// Save the user profile to the database
	return instanceModel, nil
}

// request the user profile job
func (s UserManagementServiceServerImpl) fetchUserProfileRelatedJob(request *protos.UserProfile) error {
	// create grpc client to request the job

	pp.Println("fetchUserProfileRelatedJob", request)

	s.log.WithFields(logrus.Fields{
		"request": request,
	}).Info("fetchUserProfileRelatedJob")

	job_req := createUserProfileJobParams(request)

	s.log.WithField("job_req", job_req).Info("fetchUserProfileRelatedJob")

	js_client := protos.NewJobSearchServiceProtobufClient(fmt.Sprintf("http://%s:%d", s.config.JobSearchService.Host, s.config.JobSearchService.Port), &http.Client{})
	result, err := js_client.UserJobSearch(context.Background(), job_req)
	if err != nil {
		s.log.WithFields(logrus.Fields{
			"error": err,
		}).Error("Failed to fetch user profile related job")
		return err
	}

	s.log.WithFields(logrus.Fields{
		"result": result,
	}).Info("fetchUserProfileRelatedJob: success return")

	return nil
}

func createUserProfileJobParams(request *protos.UserProfile) *protos.JobSearchRequest {
	// create grpc client to request the job
	if request == nil {
		return nil
	}

	reqSet := protos.JobSearchRequest{
		UserId:     request.UserId,
		SalaryType: protos.SalaryType_ANNUAL.Enum(),
	}

	if request.Salary != "" {
		salarySet := strings.Split(request.Salary, " -")
		if len(salarySet) == 2 {
			if minSalary, err := strconv.Atoi(salarySet[0]); err == nil {
				minSalaryInt32 := int32(minSalary)
				minSalaryInt32 = int32(float32(minSalaryInt32) * 0.8)
				reqSet.MinSalary = &minSalaryInt32
			}
			if maxSalary, err := strconv.Atoi(salarySet[1]); err == nil {
				maxSalaryInt32 := int32(maxSalary)
				maxSalaryInt32 *= 2
				reqSet.MaxSalary = &maxSalaryInt32
			}
		} else if len(salarySet) == 1 {
			if minSalary, err := strconv.Atoi(salarySet[0]); err == nil {
				minSalaryInt32 := int32(minSalary)
				minSalaryInt32 = int32(float32(minSalaryInt32) * 0.8)
				reqSet.MinSalary = &minSalaryInt32
			}
		}
	}

	if request.Location != "" {
		workLocale := strings.ReplaceAll(request.Location, "undefined", "")
		workLocale = strings.ReplaceAll(workLocale, ",", "")
		m1 := regexp.MustCompile(`^\d+`)
		workLocale = m1.ReplaceAllString(workLocale, "")
		reqSet.WorkLocale = &workLocale
	}

	for _, kw := range request.Keywords {
		reqSet.Keywords = append(reqSet.Keywords, kw.Value)
	}

	if request.Type == protos.UserProfileType_EMPLOYEE {
		classic := int32(0)
		if request.Position != "" {
			m2 := regexp.MustCompile(`\d+`)
			captured := m2.FindAllString(request.Position, -1)
			classic32, _ := strconv.Atoi(captured[0])
			classic = int32(classic32)
		}

		reqSet.Classification = &classic

		reqSet.Keywords = append(reqSet.Keywords, fmt.Sprintf("!%s", request.Title))
	} else {

		reqSet.Keywords = append(reqSet.Keywords, strings.Split(request.Title, ";")...)
	}

	return &reqSet

}
