// source: JobSearchService.proto
// Version: 1.0.0

package server

import (
	"context"
	"fmt"
	"job-seek/pkg/database/model"
	"job-seek/pkg/protos"
	"job-seek/pkg/request/linkedin_search"
	"job-seek/pkg/request/seek_api"
	"job-seek/pkg/request/seek_gql"
	"sort"
	"strings"
	"time"

	"github.com/google/uuid"
	pp "github.com/k0kubun/pp/v3"
	"github.com/samber/lo"
	"github.com/sirupsen/logrus"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func FromProtoToRequest(req *protos.JobSearchRequest) *seek_api.SeekSearchApiParams {
	var minSalary, maxSalary int
	if req.GetMinSalary() > 0 {
		minSalary = int(req.GetMinSalary())
	}
	if req.GetMaxSalary() > req.GetMinSalary() {
		maxSalary = int(req.GetMaxSalary())
	}
	salaryRange := fmt.Sprintf("%d-", minSalary)
	if minSalary == 0 && maxSalary == 0 {
		salaryRange = ""
	} else if maxSalary != 0 {
		salaryRange = fmt.Sprintf("%d-%d", minSalary, maxSalary)
	}

	return &seek_api.SeekSearchApiParams{
		// SiteKey : inherit from the domain config
		Where: req.GetWorkLocale(),
		Page:  int(req.GetPageNumber()),
		// Keywords:    implement in CreateSearchCombinations
		SalaryType:  req.SalaryType.String(),
		SalaryRange: salaryRange,
		// Locale:    inherit from the domain config,
		SeekerId:       req.UserId,
		Classification: fmt.Sprintf("%d", req.GetClassification()),
		AdvertiserId:   req.GetCompanyId(),
		UserQueryId:    req.GetCacheRef(),
	}
}

// JobSearch implements JobSearch from JobSearchServiceServer
// generated by protoc-gen-go-grpc.JobSearchServiceServer
func (s *JobSearchServiceServerImpl) JobSearch(ctx context.Context, req *protos.JobSearchRequest) (*protos.JobSearchResponse, error) {
	s.mut.TryLock()
	defer s.mut.Unlock()
	s.log.WithFields(logrus.Fields{
		"method": "JobSearch",
		"req":    req,
	}).Info("JobSearch called")

	if req.PageNumber != nil && req.CacheRef != nil {
		// continue to fetch the next page
		// get the search params from the cache
		jobCacheList := model.JobCacheListModel{
			CacheRef:    *req.CacheRef,
			UserQueryId: *req.CacheRef,
			PageNumber:  int(*req.PageNumber),
		}
		protosJob, err := jobCacheList.GetJobCacheList(s.dbClient)
		if err != nil {
			s.log.WithFields(logrus.Fields{
				"error": err,
			}).Error("fail to fetch jobs from cache")
			return nil, status.Errorf(codes.Internal, "fail to fetch jobs")
		}
		s.log.WithFields(logrus.Fields{
			"method":   "JobSearch",
			"response": protosJob,
		}).Info("JobSearch response with exist cache called")
		return protosJob, nil
	}

	jobRequest := FromProtoToRequest(req)
	// from the config
	jobRequest.SiteKey = s.config.SeekService.SiteKey
	jobRequest.Locale = s.config.SeekService.LanguageLocale
	// pp.Println("jobRequest", jobRequest)
	// pp.Println("jobRequest keyword", req.Keywords)
	combinedKeywords := seek_api.CreateSearchCombinations(req.Keywords)
	// pp.Println("combinedKeywords", combinedKeywords)
	combinedKeywords = lo.Filter(combinedKeywords, func(item string, _ int) bool {
		// maxium 3 keyword combination
		return strings.Count(item, " ") <= 2
	})

	sort.Slice(combinedKeywords, func(i, j int) bool {
		return len(combinedKeywords[i]) > len(combinedKeywords[j])
	})
	s.log.WithFields(logrus.Fields{
		"method":           "JobSearch",
		"combinedKeywords": combinedKeywords,
		"jobRequest":       jobRequest,
	}).Trace("JobSearch call API")
	postData, err := s.getPostJobsList(combinedKeywords, jobRequest)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "fail to fetch jobs")
	}

	responseData := &protos.JobSearchResponse{
		Job: postData,
	}

	return responseData, nil
}

func (s *JobSearchServiceServerImpl) getPostJobsList(combinedKeywords []string, searchParamsPreset *seek_api.SeekSearchApiParams) ([]*protos.Job, error) {
	s.log.WithFields(logrus.Fields{
		"method":             "getPostJobsList",
		"combinedKeywords":   combinedKeywords,
		"searchParamsPreset": searchParamsPreset,
	}).Trace("getPostJobsList ")
	cacheRef, _ := uuid.NewV7()

	postData := []*protos.Job{}
	// uncachedPostData := []*protos.Job{}

	firstPatchList := generateSearchParamsBatch(searchParamsPreset, combinedKeywords)

	s.log.WithFields(logrus.Fields{
		"method":         "getPostJobsList",
		"firstPatchList": firstPatchList,
	}).Trace("gernerated the batch search params")

	for _, patchParams := range firstPatchList {
		patchJobList, patchJobErr := s.fetchJobs(cacheRef.String(), &patchParams)
		if patchJobErr != nil {
			s.log.WithFields(logrus.Fields{
				"method": "getPostJobsList",
				"error":  patchJobErr,
			}).Warn("Fail to Get Patch Job, Try to continue with others params")
			continue
		}
		s.log.WithFields(logrus.Fields{
			"method": "getPostJobsList",
			// "firstPatch": firstPatch,
			"total": patchJobList.TotalCount,
			"meta":  patchJobList.SolMetadata,
		}).Debug("fetched the first patch ")
		secondPatchList := generateSearchParamsBatchFromFirstBatch(&patchParams, patchJobList)

		for _, job := range patchJobList.Data {
			jobDetail, _ := s.getJobDetail(fmt.Sprintf("%d", job.ID))
			postData = append(postData, jobDetail)
		}

		for _, continuePatch := range secondPatchList {
			continuePatchJobList, _ := s.fetchJobs(cacheRef.String(), &continuePatch)
			s.log.WithFields(logrus.Fields{
				"method": "getPostJobsList",
				// "firstPatch": firstPatch,
				"total": continuePatchJobList.TotalCount,
				"meta":  continuePatchJobList.SolMetadata,
			}).Debug("fetched the first patch ")

			for _, job := range continuePatchJobList.Data {
				jobDetail, _ := s.getJobDetail(fmt.Sprintf("%d", job.ID))
				postData = append(postData, jobDetail)
			}
		}
	}

	// firstPatch, _ := s.fetchJobs(cacheRef.String(), &firstPatchList[0])
	// s.log.WithFields(logrus.Fields{
	// 	"method": "getPostJobsList",
	// 	// "firstPatch": firstPatch,
	// 	"total": firstPatch.TotalCount,
	// 	"meta":  firstPatch.SolMetadata,
	// }).Debug("fetched the first patch ")

	// for _, job := range firstPatch.Data {
	// 	jobDetail, _ := s.getJobDetail(fmt.Sprintf("%d", job.ID))
	// 	postData = append(postData, jobDetail)
	// }

	// // go func() {
	// //continue to fetch the next page
	// secondTierPatchList := generateSearchParamsBatchFromFirstBatch(&firstPatchList[0], firstPatch)
	// // pendingJobList := []seek_api.SeekSearchApiResponseData{}
	// if len(firstPatchList) > 1 {
	// 	for _, searchParams := range firstPatchList[1:] {
	// 		// fetch jobs
	// 		resp, _ := s.fetchJobs(cacheRef.String(), &searchParams)
	// 		// pendingJobList = append(pendingJobList, resp.Data...)
	// 		secondTierPatchList = append(secondTierPatchList, generateSearchParamsBatchFromFirstBatch(&searchParams, resp)...)
	// 	}
	// }
	// for _, searchParams := range secondTierPatchList {
	// 	// fetch jobs
	// 	resp, _ := s.fetchJobs(cacheRef.String(), &searchParams)
	// 	// pendingJobList = append(pendingJobList, resp.Data...)
	// 	for _, job := range resp.Data {
	// 		jobDetail, _ := s.getJobDetail(fmt.Sprintf("%d", job.ID))
	// 		postData = append(postData, jobDetail)
	// 	}
	// }

	// }()
	s.log.Infof("Total jobs fetched: %d", len(postData))

	return postData, nil
}

func generateSearchParamsBatch(preset *seek_api.SeekSearchApiParams, keywords []string) []seek_api.SeekSearchApiParams {
	var searchParamsBatch []seek_api.SeekSearchApiParams
	for _, keyword := range keywords {
		searchParamsBatch = append(searchParamsBatch, seek_api.SeekSearchApiParams{
			SeekerId:       preset.SeekerId,
			AdvertiserId:   preset.AdvertiserId,
			Keywords:       keyword,
			Page:           1,
			PageSize:       100,
			SalaryType:     preset.SalaryType,
			SalaryRange:    preset.SalaryRange,
			Where:          preset.Where,
			Classification: preset.Classification,
		})
	}
	return searchParamsBatch
}
func generateSearchParamsBatchFromFirstBatch(firstSearch *seek_api.SeekSearchApiParams, response *seek_api.SeekSearchApiResponse) []seek_api.SeekSearchApiParams {
	var searchParamsBatch []seek_api.SeekSearchApiParams
	totalPage := 0
	if response.TotalCount != 0 {
		totalPage = response.SolMetadata.PageSize / response.TotalCount
	}
	pp.Println("paging", map[string]interface{}{
		"category":        firstSearch.Classification,
		"calculation":     totalPage,
		"totalPage":       totalPage,
		"apiTotalPage":    response.TotalPages,
		"apiPageSize":     response.SolMetadata.PageSize,
		"acturalPageSize": len(response.Data),
		"totalCount":      response.TotalCount,
	})
	for i := 2; i <= response.TotalPages; i++ {
		searchParamsBatch = append(searchParamsBatch, seek_api.SeekSearchApiParams{
			SeekerId:       firstSearch.SeekerId,
			Keywords:       firstSearch.Keywords,
			Page:           i,
			PageSize:       100,
			SalaryType:     firstSearch.SalaryType,
			SalaryRange:    firstSearch.SalaryRange,
			Where:          firstSearch.Where,
			UserQueryId:    response.UserQueryID,
			Classification: firstSearch.Classification,
		})
	}
	return searchParamsBatch
}

func (s *JobSearchServiceServerImpl) fetchJobs(cacheRef string, preset *seek_api.SeekSearchApiParams) (*seek_api.SeekSearchApiResponse, error) {
	// postData := []seek_api.SeekSearchApiResponseData{}
	timeStart := time.Now()
	data, err := seek_api.SeekSearchApiForApi(preset, &s.config.SeekService)
	if err != nil {
		s.log.WithFields(logrus.Fields{
			"error":      err,
			"preset":     preset,
			"keyword":    preset.Keywords,
			"pageNumber": preset.Page,
		}).Errorf("fail to fetch seek api in first page")
		return nil, err
	}
	go func() {
		jobCacheList := model.JobCacheListModel{}
		jobCacheList.FromSearchResult(preset, &data)
		jobCacheList.CacheRef = cacheRef

		s.log.WithFields(logrus.Fields{
			"method":        "fetchJobs",
			"jobCacheModel": jobCacheList,
		}).Trace("fail to store job cache list")

		storeErr := jobCacheList.CreateJobCacheList(s.dbClient)
		if storeErr != nil {
			s.log.WithFields(logrus.Fields{
				"error": storeErr,
			}).Error("fail to store job cache list")
		}
	}()
	timeTook := time.Since(timeStart)
	time.Sleep(time.Duration(s.config.SeekService.CoolDown)*time.Second - timeTook)
	return &data, nil
}

func (s *JobSearchServiceServerImpl) getJobDetail(jobId string) (*protos.Job, error) {
	// jobDetail := new(protos.Job)

	s.log.WithFields(logrus.Fields{
		"method": "getJobDetail",
		"jobId":  jobId,
	}).Trace("get Job Detail, before the request db cache")

	var err error
	var instJobs *protos.Job

	instJobs, err = s.getJobDetailFromDB(jobId)

	if err != nil {
		s.log.WithFields(logrus.Fields{
			"error": err,
			"jobId": jobId,
		}).Warn("fail to fetch job detail from db")
	}
	if instJobs != nil {
		s.log.WithFields(logrus.Fields{
			"method": "getJobDetail",
			"jobId":  jobId,
			"job":    instJobs,
		}).Trace("get Job Detail from the request db cache")

		return instJobs, nil
	}
	startTime := time.Now()
	var jobDetailData *seek_gql.JobDetailResponse
	jobDetailData, err = seek_gql.GetPostDetailForApi(jobId, &s.config.SeekService)
	if err != nil {
		s.log.WithFields(logrus.Fields{
			"method": "getJobDetail",

			"error": err,
			"jobId": jobId,
		}).Error("fail to fetch job detail from graphql")
		return nil, err
	}

	s.log.WithFields(logrus.Fields{
		"method":        "getJobDetail",
		"jobDetailData": jobId,
	}).Trace("get Job Detail from the api")

	jobDetail := seek_gql.ConvertPostGQLToProto(jobDetailData)

	s.log.WithFields(logrus.Fields{
		"method":       "getJobDetail",
		"jobId":        jobId,
		"job":          jobDetailData,
		"jobConverted": jobDetail,
	}).Trace("job detail fetched")

	tmpCompantDetail := linkedin_search.ExtractCompanyProfileGQL(&jobDetailData.Data.JobDetails)
	s.log.WithFields(logrus.Fields{
		"method":           "getJobDetail",
		"jobId":            jobId,
		"tmpCompantDetail": tmpCompantDetail,
	}).Trace("before get the company detail")
	if tmpCompantDetail.Name == "Private Advertiser" && strings.HasPrefix(tmpCompantDetail.ReferenceId, "pa") {
		s.log.WithFields(logrus.Fields{
			"method":        "getJobDetail",
			"companyDetail": tmpCompantDetail,
		}).Trace("resolved the company detail, it is private advertiser")
		jobDetail.CompanyDetail = tmpCompantDetail.ToProto()
	} else {
		compantDetail, err := s.getCompanyDetailFromDB(tmpCompantDetail.ReferenceId)
		if err != nil {
			s.log.WithFields(logrus.Fields{
				"method":    "getJobDetail",
				"error":     err,
				"jobId":     jobId,
				"companyId": tmpCompantDetail.ReferenceId,
			}).Warn("fail to fetch company detail from db")
			s.log.Trace("fetch company detail from api")
			err = nil

			compantDetail, err = s.getCompanyDetailFromAPICreate(tmpCompantDetail)
			if err != nil {
				s.log.WithFields(logrus.Fields{
					"method":    "getJobDetail",
					"error":     err,
					"jobId":     jobId,
					"companyId": tmpCompantDetail.ReferenceId,
				}).Warn("fail to fetch company detail via api")
				jobDetail.CompanyDetail = tmpCompantDetail.ToProto()
			} else {
				s.log.WithFields(logrus.Fields{
					"method":        "getJobDetail",
					"companyDetail": compantDetail,
				}).Trace("fail to fetch company detail via api")
				jobDetail.CompanyDetail = compantDetail
			}
			// since it is not in the db, insert it
			go func() {
				s.log.WithFields(logrus.Fields{
					"method":        "getJobDetail",
					"companyDetail": jobDetail.CompanyDetail,
				}).Trace("try to insert company detail to db")
				s.storeCompanyDetailToDB(jobDetail.CompanyDetail)
			}()
		} else {
			s.log.WithFields(logrus.Fields{
				"method":        "getJobDetail",
				"companyDetail": compantDetail,
			}).Trace("resolved the company detail from db")
			jobDetail.CompanyDetail = compantDetail
		}
	}

	// store job detail to db
	go func() {
		s.log.WithFields(logrus.Fields{
			"method": "getJobDetail",
			"job":    jobDetail,
		}).Trace("try to insert company detail to db")
		s.storeJobDetailToDB(jobDetail)
	}()

	timeTook := time.Since(startTime)
	s.log.Info("Time took to fetch job detail: ", timeTook)
	waitTime := time.Duration(s.config.SeekService.CoolDown)*time.Second - timeTook
	if waitTime > 0 {
		s.log.Infof("and wait for %d seconds", waitTime)
		time.Sleep(waitTime)
	}
	return jobDetail, nil
}

func (s *JobSearchServiceServerImpl) getJobDetailFromDB(jobId string) (*protos.Job, error) {
	jobModel := model.JobModel{
		PostId: jobId,
	}
	data, err := jobModel.GetModel(s.dbClient)
	if err != nil {
		s.log.WithFields(logrus.Fields{
			"error": err,
			"jobId": jobId,
		}).Error("fail to fetch job detail from db")
		return nil, err
	}
	return data, nil
}

func (s *JobSearchServiceServerImpl) storeJobDetailToDB(jobDetail *protos.Job) error {
	jobModel := model.JobModel{}
	jobModel.FromProto(jobDetail)
	err := jobModel.CreateModel(s.dbClient)
	if err != nil {
		s.log.WithFields(logrus.Fields{
			"error": err,
			"jobId": jobDetail.PostId,
		}).Error("fail to store job detail to db")
		return err
	}
	return nil
}

// get company detail : see in get_company_detail.go
