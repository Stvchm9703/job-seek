// source: JobSearchService.proto
// Version: 1.0.0

package server

import (
	"context"
	"fmt"
	"job-seek/pkg/dataset/job_classification"
	"job-seek/pkg/dataset/location/au"
	"job-seek/pkg/protos"
	"job-seek/pkg/request/seek_api"
	"math"
	"sort"
	"strings"

	"github.com/google/uuid"
	"github.com/samber/lo"
	logrus "github.com/sirupsen/logrus"
	"github.com/twitchtv/twirp"
)

// UserJobSearch implements UserJobSearch from JobSearchServiceServer
// generated by protoc-gen-go-grpc.JobSearchServiceServer
// for the user-profile prefetching similar jobs,
// it will take
//   - 60 similar jobs with each 5 set of keywords combination
//   - 10 different from different industries
//   - 10 different from different locations
//   - 10 different from different job types
//   - 10 different from different job titles
func (s *JobSearchServiceServerImpl) UserJobSearch(ctx context.Context, req *protos.JobSearchRequest) (*protos.JobSearchResponse, error) {

	s.mut.TryLock()
	defer s.mut.Unlock()

	s.log.WithFields(logrus.Fields{
		"method":  "UserJobSearch",
		"request": req,
	}).Info("UserJobSearch called")

	jobRequest := FromProtoToRequest(req)
	// from the config
	jobRequest.SiteKey = s.config.SeekService.SiteKey
	jobRequest.Locale = s.config.SeekService.LanguageLocale

	// 3 set parameters
	combinedKeywords := seek_api.CreateSearchCombinationsV2(req.Keywords)
	// pp.Println("query", combinedKeywords)

	combinedKeywords = lo.Filter(combinedKeywords, func(item string, _ int) bool {
		// maxium 3 keyword combination
		return strings.Count(item, " ") >= 4 && strings.Count(item, " ") <= 15
	})

	sort.Slice(combinedKeywords, func(i, j int) bool {
		return len(combinedKeywords[i]) > len(combinedKeywords[j])
	})

	maxCap := math.Min(5, float64(len(combinedKeywords)))
	combinedKeywords = combinedKeywords[:int32(maxCap)]

	s.log.WithFields(logrus.Fields{
		"method":           "UserJobSearch",
		"combinedKeywords": combinedKeywords,
		"jobRequest":       jobRequest,
	}).Trace("UserJobSearch called")

	var cacheRefString string
	if req.GetCacheRef() != "" {
		cacheRefString = req.GetCacheRef()
	} else {
		cacheRef, _ := uuid.NewV7()
		cacheRefString = cacheRef.String()
	}

	postData, err := s.getPostJobsListSinglar(cacheRefString, combinedKeywords, jobRequest)
	if err != nil {
		// return nil, status.Errorf(codes.Internal, "fail to fetch jobs")
		return nil, twirp.InternalErrorWith(err)
	}

	// get the job title from the keywords
	jbtitle, _ := lo.Find(req.Keywords, func(key string) bool {
		return strings.Contains(key, "!") || strings.Contains(key, "*")
	})
	jbtitle = strings.ReplaceAll(jbtitle, "!", "")

	// 1 set of different from different locations
	locationsSet := jobRequest
	locationsSet.Keywords = jbtitle
	locationsSet.Where = au.FindParentLocation(req.GetWorkLocale())
	locationsSet.PageSize = 10
	locationsPostData, err := s.batchFetchJobTask(cacheRefString, locationsSet)
	if err != nil {
		// return nil, status.Errorf(codes.Internal, "fail to fetch jobs")
		return nil, twirp.InternalErrorWith(err)
	}

	// 1 set of different from different job types
	jobTypesSet := jobRequest
	jobTypesSet.Classification = job_classification.FindParentCategory(jobTypesSet.Classification)
	jobTypesSet.PageSize = 10
	jobRequest.Where = req.GetWorkLocale()
	jobTypesPostData, err := s.batchFetchJobTask(cacheRefString, jobTypesSet)
	if err != nil {
		// return nil, status.Errorf(codes.Internal, "fail to fetch jobs")
		return nil, twirp.InternalErrorWith(err)
	}

	// 1 set of different from different job titles
	jobTitlesSet := jobRequest
	// jobTitlesSet.Keywords =  "Senior "
	jobTitlesSet.Keywords = "Senior " + jbtitle
	jobTitlesSet.PageSize = 10
	jobTitlesSet.Where = req.GetWorkLocale()

	jobTitlesPostData, err := s.batchFetchJobTask(cacheRefString, jobTitlesSet)
	if err != nil {
		// return nil, status.Errorf(codes.Internal, "fail to fetch jobs")
		return nil, twirp.InternalErrorWith(err)
	}

	postData = append(postData, locationsPostData...)
	postData = append(postData, jobTypesPostData...)
	postData = append(postData, jobTitlesPostData...)

	responseData := &protos.JobSearchResponse{
		Job: postData,
	}

	return responseData, nil

}

func (s *JobSearchServiceServerImpl) getPostJobsListSinglar(cacheRefString string, combinedKeywords []string, searchParamsPreset *seek_api.SeekSearchApiParams) ([]*protos.Job, error) {

	// s.LogTrace("getPostJobsListSinglar", "Get Post Jobs List", map[string]interface{}{
	// 	"combinedKeywords":   combinedKeywords,
	// 	"searchParamsPreset": searchParamsPreset,
	// })

	postData := []*protos.Job{}
	// uncachedPostData := []*protos.Job{}

	firstPatchList := generateSearchParamsBatch(searchParamsPreset, combinedKeywords)

	s.log.WithFields(logrus.Fields{
		"method":         "getPostJobsListSinglar",
		"firstPatchList": firstPatchList,
	}).Trace("Get Post Jobs List")

	for _, patchParams := range firstPatchList {
		returnedPostData, _ := s.batchFetchJobTask(cacheRefString, &patchParams)
		if returnedPostData != nil {
			postData = append(postData, returnedPostData...)
		}
	}
	s.log.Infof("Total jobs fetched: %d", len(postData))

	return postData, nil
}

// - 10 different from different industries
func (s *JobSearchServiceServerImpl) batchFetchJobTask(cacheRefString string, searchParamsPreset *seek_api.SeekSearchApiParams) ([]*protos.Job, error) {

	patchJobList, patchJobErr := s.fetchJobs(cacheRefString, searchParamsPreset)

	postData := []*protos.Job{}

	if patchJobErr != nil {
		s.log.WithFields(logrus.Fields{
			"method": "batchFetchJobTask",
			"error":  patchJobErr,
		}).Error("Fail to Get Patch Job, Try to continue with others params")

		return nil, patchJobErr
	}

	s.log.WithFields(logrus.Fields{
		"method": "batchFetchJobTask",
		"total":  patchJobList.TotalCount,
		"meta":   patchJobList.SolMetadata,
	}).Debug("Fetched the first patch")

	for _, job := range patchJobList.Data {
		jobDetail, _ := s.getJobDetail(fmt.Sprintf("%d", job.ID))
		postData = append(postData, jobDetail)
	}

	return postData, nil
}
