// source: JobSearchService.proto
// Version: 1.0.0

package server

import (
	"context"
	"fmt"
	"job-seek/pkg/protos"
	"job-seek/pkg/request/seek_api"
	"time"

	"github.com/sirupsen/logrus"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func FromProtoToRequest(req *protos.JobSearchRequest) *seek_api.SeekSearchApiParams {
	return &seek_api.SeekSearchApiParams{
		// SiteKey : inherit from the domain config
		Where: *req.WorkLocale,
		Page:  int(*req.PageNumber),
		// Keywords:    implement in CreateSearchCombinations
		SalaryType:  req.SalaryType.String(),
		SalaryRange: fmt.Sprintf("%v-%v", req.MinSalary, req.MaxSalary),
		// Locale:    inherit from the domain config,
		SeekerId: req.UserId,
		// Classification: todo(),
		AdvertiserId: *req.CompanyId,
		UserQueryId:  *req.CacheRef,
	}
}

// JobSearch implements JobSearch from JobSearchServiceServer
// generated by protoc-gen-go-grpc.JobSearchServiceServer
func (s JobSearchServiceServerImpl) JobSearch(ctx context.Context, req *protos.JobSearchRequest) (*protos.JobSearchResponse, error) {
	s.mut.TryLock()
	defer s.mut.Unlock()
	if req.PageNumber != nil && req.CacheRef != nil {
		// continue to fetch the next page
	}

	jobRequest := FromProtoToRequest(req)
	// from the config
	jobRequest.SiteKey = s.config.SeekService.SiteKey
	jobRequest.Locale = s.config.SeekService.LanguageLocale

	combinedKeywords := seek_api.CreateSearchCombinations(req.Keywords)

	postData, err := s.getPostPobsList(combinedKeywords, jobRequest)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "fail to fetch jobs")
	}

	responseData := &protos.JobSearchResponse{
		Job: postData,
	}

	return responseData, nil
}

type JobCacheList struct {
	CacheRef       string
	UserQueryId    string
	Job            []string
	PageNumber     int
	TotalCount     int
	TotalPage      int
	CurrentKeyword string
	SearchParams   seek_api.SeekSearchApiParams
}

func (s JobSearchServiceServerImpl) getPostPobsList(combinedKeywords []string, searchParamsPreset *seek_api.SeekSearchApiParams) ([]*protos.Job, error) {

	// postData := []seek_api.SeekSearchApiResponseData{}
	// uncachedPostData := []seek_api.SeekSearchApiResponseData{}

	postData := []*protos.Job{}
	// uncachedPostData := []*protos.Job{}

	for _, keywordCombination := range combinedKeywords {
		tempPostData, error := s.fetchJobs(searchParamsPreset, keywordCombination)
		if error != nil {
			s.log.WithFields(logrus.Fields{
				"error":              error,
				"keywordCombination": keywordCombination,
			}).Errorf("fail to fetch jobs")
			return nil, error
		}

		// check the exist data in cache
		// todo implement to the meilisearch
		// for _, post := range tempPostData {
		// 	isExist, _ := store.CheckKeyPostDetailCache(fmt.Sprintf("%d", post.ID))
		// 	if !isExist {
		// 		postData = append(postData, post)
		// 	}
		// 	// }
		// }
	}
	s.log.Infof("Total jobs fetched: %d", len(postData))

	return postData, nil
}

func (s JobSearchServiceServerImpl) fetchJobs(preset *seek_api.SeekSearchApiParams, keyword string) ([]seek_api.SeekSearchApiResponseData, error) {
	postData := []seek_api.SeekSearchApiResponseData{}

	data, err := seek_api.SeekSearchApiWithPreset(preset, keyword, 1, "", "")
	if err != nil {
		s.log.WithFields(logrus.Fields{
			"error":      err,
			"preset":     preset,
			"keyword":    keyword,
			"pageNumber": 1,
		}).Errorf("fail to fetch seek api in first page")
		return nil, err
	}
	userId := data.SearchParams.UserId
	queryId := data.SearchParams.UserQueryId
	// log.Printf("totel count : %d\n", data.TotalCount)

	pageTotal := data.TotalPages

	for pageNumber := 1; pageNumber <= pageTotal; pageNumber++ {
		time.Sleep(time.Duration(s.config.SeekService.CoolDown) * time.Millisecond)
		data, err := seek_api.SeekSearchApiWithPreset(preset, keyword, pageNumber, userId, queryId)
		if err != nil {
			s.log.WithFields(logrus.Fields{
				"error":      err,
				"preset":     preset,
				"keyword":    keyword,
				"pageNumber": pageNumber,
			}).Errorf("fail to fetch seek api in continue page")
		}
		postData = append(postData, data.Data...)
	}
	return postData, nil
}
