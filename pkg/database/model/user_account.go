// Path: job-seek/pkg/database/model/
// code generated by tools/generate_db_model_query/main.go

package model

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"job-seek/pkg/protos"
	"log"
	"strings"
	"text/template"

	"github.com/k0kubun/pp/v3"
	"github.com/samber/lo"
	surrealdb "github.com/surrealdb/surrealdb.go"
)

type UserAccountModel struct {
	ID           string `json:"id,omitempty"`
	UserName     string `json:"user_name"`
	UserPassword string `json:"user_password"`
	UserEmail    string `json:"user_email"`
	UserPhone    string `json:"user_phone"`
	UserAddress  string `json:"user_address"`
}

func (m *UserAccountModel) ToProto() *protos.UserAccount {
	return &protos.UserAccount{
		Id:           m.ID,
		UserName:     m.UserName,
		UserPassword: m.UserPassword,
		UserEmail:    m.UserEmail,
		UserPhone:    m.UserPhone,
		UserAddress:  m.UserAddress,
	}
}

func (m *UserAccountModel) FromProto(p *protos.UserAccount) {
	m.ID = p.Id
	m.UserName = p.UserName
	m.UserPassword = p.UserPassword
	m.UserEmail = p.UserEmail
	m.UserPhone = p.UserPhone
	m.UserAddress = p.UserAddress
}

func (m *UserAccountModel) GetModel(db *surrealdb.DB) (*protos.UserAccount, error) {
	if db == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	result, err := db.Select(fmt.Sprintf("UserAccount:%s", m.ID))
	if err != nil {
		return nil, err
	}

	data := new(UserAccountModel)
	err = surrealdb.Unmarshal(result, data)
	if err != nil {
		return nil, errors.Join(fmt.Errorf("failed to unmarshal UserAccountModel"), err, pp.Errorf("result", result))
	}
	return data.ToProto(), nil
}

func (m *UserAccountModel) GetModelByWildKey(db *surrealdb.DB) (*protos.UserAccount, error) {
	if db == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	query := fmt.Sprintf(`
	SELECT * FROM UserAccount 
		WHERE UserName = '%s'
		OR UserEmail = '%s'
		OR id = '%s';
	`, m.UserName, m.UserEmail, m.ID)

	result, err := db.Query(query, m)
	if err != nil {
		return nil, errors.Join(err, fmt.Errorf("query: %s", query), pp.Errorf("message:", result))
	}

	var message map[string]interface{}
	surrealdb.Unmarshal(result, message)
	if err != nil {
		fmt.Println("query:", query)
		pp.Println("message:", message)
		return nil, errors.Join(err, fmt.Errorf("query: %s", query), pp.Errorf("message: %v", message))
	}

	var queryResult []QueryResult[UserAccountModel]
	// err = surrealdb.Unmarshal(result, jobqueryResult)
	jsonResult, _ := json.Marshal(result)
	err = json.Unmarshal(jsonResult, &queryResult)
	if err != nil {
		errorWrap := errors.Join(err, fmt.Errorf("query: %s", query), fmt.Errorf("raw: %s", jsonResult))
		log.Fatalf("error: %v", errorWrap)
		return nil, errorWrap
		// return nil, err
	}
	// pp.Println("jobs:", jobqueryResult)
	if len(queryResult) == 0 || len(queryResult[0].Result) == 0 {
		return nil, fmt.Errorf("no data found")
	}
	// pp.Println("jobs:", jobqueryResult[0].Result[0])
	return queryResult[0].Result[0].ToProto(), nil

}

func (m *UserAccountModel) CreateModel(sd *surrealdb.DB) error {
	if sd == nil {
		return fmt.Errorf("database connection is nil")
	}
	// _, err := sd.Create(fmt.Sprintf("UserAccount:%s", m.UserId), m)
	queryTemplate, _ := template.New("createUserAccount").Parse(`
BEGIN TRANSACTION;
LET $is_exist = (
    SELECT id FROM UserAccount 
    WHERE UserName = $UserName 
        OR UserEmail = $UserEmail 
        OR UserPhone = $UserPhone
);

IF count($is_exist) > 0
{
    THROW 'User already exist';
}
;
CREATE UserAccount CONTENT {
	UserAddress: $UserAddress,
	UserEmail: $UserEmail,
	UserName: $UserName,
	UserPassword: $UserPassword,
	UserPhone: $UserPhone
} RETURN id;
COMMIT TRANSACTION;
	`)
	var doc bytes.Buffer
	var err error
	err = queryTemplate.Execute(&doc, m)
	if err != nil {
		return err
	}
	query := strings.ReplaceAll(doc.String(), "\n", " ")
	query = strings.ReplaceAll(query, "\t", " ")
	query = strings.ReplaceAll(query, "\r", " ")
	result, err := sd.Query(query, m)
	if err != nil {
		return errors.Join(err, fmt.Errorf("query: %s", query), pp.Errorf("message:", result))
	}

	var queryResult []QueryResult[*UserAccountModel]
	// err = surrealdb.Unmarshal(result, jobqueryResult)
	jsonResult, _ := json.Marshal(result)
	err = json.Unmarshal(jsonResult, &queryResult)
	if err != nil {
		errorWrap := errors.Join(err, fmt.Errorf("query: %s", query), fmt.Errorf("raw: %s", jsonResult))
		log.Fatalf("error: %v", errorWrap)
		return errorWrap
		// return nil, err
	}

	queryResult = lo.Filter(queryResult, func(x QueryResult[*UserAccountModel], _ int) bool { return x.Result != nil })
	println(queryResult)
	// var message map[string]interface{}
	// surrealdb.Unmarshal(result, message)
	// if err != nil {
	// 	fmt.Println("query:", query)
	// 	pp.Println("message:", message)
	// 	return errors.Join(err, fmt.Errorf("query: %s", query), pp.Errorf("message: %v", message))
	// }

	return nil

}

func (m *UserAccountModel) UpdateModel(sd *surrealdb.DB) error {
	if sd == nil {
		return fmt.Errorf("database connection is nil")
	}
	if m.ID == "" {
		return fmt.Errorf("ID is empty")
	}
	_, err := sd.Update(fmt.Sprintf("UserAccount:%s", m.ID), m)
	return err
}

func (m *UserAccountModel) DefineModel(sd *surrealdb.DB) error {
	if sd == nil {
		return fmt.Errorf("database connection is nil")
	}
	query := `
DEFINE  TABLE IF NOT EXISTS UserAccount SCHEMAFULL;
-- Field definition
	DEFINE FIELD IF NOT EXISTS	UserName 				ON TABLE UserAccount TYPE		string;
	DEFINE FIELD IF NOT EXISTS	UserPassword		ON TABLE UserAccount TYPE		string;
	DEFINE FIELD IF NOT EXISTS	UserEmail 			ON TABLE UserAccount TYPE		string;
	DEFINE FIELD IF NOT EXISTS	UserPhone 			ON TABLE UserAccount TYPE		string;
	DEFINE FIELD IF NOT EXISTS	UserAddress 		ON TABLE UserAccount TYPE		string;
`
	_, err := sd.Query(query, nil)
	return err
}
